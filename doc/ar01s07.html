<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Adding ModAssert to your application</title><link rel="stylesheet" href="style.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.70.1"><link rel="start" href="index.html" title="Modular Assertions version 2.0.6"><link rel="up" href="index.html" title="Modular Assertions version 2.0.6"><link rel="prev" href="ar01s06.html" title="Adding ModAssert to individual projects"><link rel="next" href="ar01s08.html" title="The purpose of assertion macros"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Adding ModAssert to your application</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ar01s06.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ar01s08.html">Next</a></td></tr></table><hr></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id513039"></a>Adding ModAssert to your application</h2></div></div></div><div class="itemizedlist"><ul type="disc"><li>Link the ModAssert and the Rich Booleans library with your executable. This is not necessary for
Visual C++, because ModAssert and RichBool use
autolinking with Visual C++, i.e. their headerfiles contain directives that cause the linker to include the correct
library for the configuration that you use, if you include <code class="filename">modassert/handler.hpp</code>
in at least one implementation file. In theory this should also work with Borland C++ Builder,
but this hasn't been tested.</li><li>Set the assertion handler at initialization time (typically in the <code class="code">main</code> method,
or a <code class="classname">App</code> object).
    <div class="itemizedlist"><ul type="opencircle"><li style="list-style-type: circle">If you use the Windows 32 API, you can use the <code class="classname">ModAssert::HandlerWin32</code>
            class by calling <code class="code">ModAssert::SetWin32Handler()</code> (see <a href="ar01s16.html#Win32" title="Windows 32">the section called &#8220;Windows 32&#8221;</a>).</li><li style="list-style-type: circle">If you use wxWidgets, you can use the <code class="classname">ModAssert::HandlerWx</code>
            class by calling <code class="code">ModAssert::SetWxHandler()</code> (see <a href="ar01s16.html#WxWidgets" title="wxWidgets">the section called &#8220;wxWidgets&#8221;</a>).</li><li style="list-style-type: circle">For console applications, you can use the <code class="classname">ModAssert::HandlerConsole</code>
            class by calling <code class="code">ModAssert::SetConsoleHandler()</code> (see <a href="ar01s16.html#Console" title="Console applications">the section called &#8220;Console applications&#8221;</a>).</li><li style="list-style-type: circle">Otherwise, you can write your own ModAssertHandler
            (see <a href="ar01s17.html" title="Processing assertions (advanced)">the section called &#8220;Processing assertions (advanced)&#8221;</a> on how to do this).</li></ul></div></li><li>Include the headerfile <code class="filename">modassert/assert.hpp</code> in every file where you want to use
Modular Assertions.</li></ul></div><p>The example projects in the directory <code class="filename">demos</code> that are included in the download
might help clarify how to do all this.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id513135"></a>Breaking into code</h3></div></div></div><a class="indexterm" name="id513139"></a><p>If an assertion or check is reported, and a <code class="classname">Responder</code> object is installed
    (see <a href="ar01s17.html#Display" title="The Responder object">the section called &#8220;The Responder object&#8221;</a>), you get the option to debug, i.e. to break into the
    code. There is code to do this for different compilers, but this has only been tested with
    Microsoft Visual C++ 6.0, .NET and Dev-C++. If it doesn't work with your compiler, add the definition
    <code class="code">#define MOD_ASSERT_BREAK_HERE ModAssert::ManualBreak()</code> in the file <code class="filename">include/modassert/assert.hpp</code>
    after the other definitions of <code class="code">MOD_ASSERT_BREAK_HERE</code> (depending on your compiler, it might already
    be defined to this), and manually set a breakpoint in the method <code class="code">ManualBreak()</code>
    in the file <code class="filename">src/handler.cpp</code>.</p><p>Note that breaking into the code is only possible if a debugger is attached. Therefore this option is
	disabled if the symbol <code class="code">NDEBUG</code> is defined. If it is not defined, the Win32 ModAssert handler
	checks if this is the case using the function <code class="code">IsDebuggerPresent()</code>. If not, the option to debug
	is disabled. Other ModAssert handlers don't do this; in that case selecting the debug option may cause
	a crash.</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ar01s06.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ar01s08.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Adding ModAssert to individual projects </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> The purpose of assertion macros</td></tr></table></div></body></html>
